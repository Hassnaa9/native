// Copyright (c) 2024, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import '../../ast/_core/interfaces/declaration.dart';
import '../../ast/_core/shared/parameter.dart';
import '../../ast/_core/shared/referred_type.dart';
import '../../ast/declarations/compounds/members/initializer_declaration.dart';
import '../../ast/declarations/compounds/members/method_declaration.dart';
import '../../ast/declarations/compounds/members/property_declaration.dart';
import '../_core/unique_namer.dart';
import '../transform.dart';
import 'transform_function.dart';
import 'transform_referred_type.dart';

Declaration transformInitializer(
  InitializerDeclaration originalInitializer,
  PropertyDeclaration wrappedClassInstance,
  UniqueNamer globalNamer,
  TransformationState state,
) {
  final transformedParams = originalInitializer.params
      .map(
        (param) => Parameter(
          name: param.name,
          internalName: param.internalName,
          type: transformReferredType(param.type, globalNamer, state),
        ),
      )
      .toList();

  if (originalInitializer.async) {
    final methodReturnType = transformReferredType(
      wrappedClassInstance.type,
      globalNamer,
      state,
    );

    return MethodDeclaration(
      id: originalInitializer.id,
      name: '${originalInitializer.name}Wrapper',
      source: originalInitializer.source,
      availability: originalInitializer.availability,
      returnType: originalInitializer.isFailable
          ? OptionalType(methodReturnType)
          : methodReturnType,
      params: transformedParams,
      hasObjCAnnotation: true,
      statements: _generateMethodStatements(
        originalInitializer,
        wrappedClassInstance,
        methodReturnType,
        transformedParams,
        state, // ADD STATE HERE
      ),
      throws: originalInitializer.throws,
      async: originalInitializer.async,
      isStatic: true,
    );
  }

  final transformedInitializer = InitializerDeclaration(
    id: originalInitializer.id,
    source: originalInitializer.source,
    availability: originalInitializer.availability,
    params: transformedParams,
    hasObjCAnnotation: true,
    isFailable: originalInitializer.isFailable,
    throws: originalInitializer.throws,
    async: originalInitializer.async,
    // Because the wrapper class extends NSObject that has an initializer with
    // no parameters. If we make a similar parameterless initializer we need
    // to add `override` keyword.
    isOverriding: transformedParams.isEmpty,
  );

  transformedInitializer.statements = _generateInitializerStatements(
    originalInitializer,
    wrappedClassInstance,
    transformedInitializer,
    state, // ADD STATE HERE
  );

  return transformedInitializer;
}

List<String> _generateInitializerStatements(
  InitializerDeclaration originalInitializer,
  PropertyDeclaration wrappedClassInstance,
  InitializerDeclaration transformedInitializer,
  TransformationState state, // ADD STATE PARAMETER
) {
  final (instanceConstruction, localNamer) = _generateInstanceConstruction(
    originalInitializer,
    wrappedClassInstance,
    transformedInitializer.params,
    state, // PASS STATE HERE
  );
  if (originalInitializer.isFailable) {
    final instance = localNamer.makeUnique('instance');
    return [
      'if let $instance = $instanceConstruction {',
      '  ${wrappedClassInstance.name} = $instance',
      '} else {',
      '  return nil',
      '}',
    ];
  } else {
    return ['${wrappedClassInstance.name} = $instanceConstruction'];
  }
}

List<String> _generateMethodStatements(
  InitializerDeclaration originalInitializer,
  PropertyDeclaration wrappedClassInstance,
  ReferredType wrapperClass,
  List<Parameter> transformedParams,
  TransformationState state, // ADD STATE PARAMETER
) {
  final (instanceConstruction, localNamer) = _generateInstanceConstruction(
    originalInitializer,
    wrappedClassInstance,
    transformedParams,
    state, // PASS STATE HERE
  );
  final instance = localNamer.makeUnique('instance');
  if (originalInitializer.isFailable) {
    return [
      'if let $instance = $instanceConstruction {',
      '  return ${wrapperClass.swiftType}($instance)',
      '} else {',
      '  return nil',
      '}',
    ];
  } else {
    return [
      'let $instance = $instanceConstruction',
      'return ${wrapperClass.swiftType}($instance)',
    ];
  }
}

(String, UniqueNamer) _generateInstanceConstruction(
  InitializerDeclaration originalInitializer,
  PropertyDeclaration wrappedClassInstance,
  List<Parameter> transformedParams,
  TransformationState state, // ADD STATE PARAMETER
) {
  final localNamer = UniqueNamer();
  final arguments = generateInvocationParams(
    localNamer,
    originalInitializer.params,
    transformedParams,
    state, // PASS STATE HERE
  );
  var instanceConstruction =
      '${wrappedClassInstance.type.swiftType}($arguments)';
  if (originalInitializer.async) {
    instanceConstruction = 'await $instanceConstruction';
  }
  if (originalInitializer.throws) {
    instanceConstruction = 'try $instanceConstruction';
  }
  return (instanceConstruction, localNamer);
}
